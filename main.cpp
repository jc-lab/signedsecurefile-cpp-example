#include <stdio.h>

#include <openssl/crypto.h>
#include <openssl/err.h>
#include <openssl/asn1.h>
#include <openssl/x509.h>

#include "signedsecurefile/InputStream.hpp"
#include "signedsecurefile/OutputStream.hpp"

void exportECPubKey(EC_KEY *ecKey)
{
	unsigned char buffer[1024];
	unsigned char *ptr = buffer;

	EVP_PKEY *pkey = EVP_PKEY_new();
	EC_KEY_set_asn1_flag(ecKey, 1);;
	EVP_PKEY_set1_EC_KEY(pkey, ecKey);
	int size = i2d_PUBKEY(pkey, &ptr);

	printf("i2d_PublicKey : %d\n", size);
	for (int i = 0; i < size; i++)
	{
		printf("(byte)0x%02x, ", buffer[i]);
	}
	printf("\n");

	EVP_PKEY_free(pkey);
}

#if 0
int main()
{
	const unsigned char encData[] = {
		//0x0A,0x9B,0xD8,0x13,0x97,0x1F,0x93,0xE8,0x6B,0x7E,0xDF,0x05,0x70,0x54,0x02,0x02,0x02,0x01,0x26,0x01,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x84,0x00,0x3F,0x30,0x81,0x81,0x02,0x01,0x00,0x30,0x10,0x06,0x07,0x2A,0x86,0x48,0xCE,0x3D,0x02,0x01,0x06,0x05,0x2B,0x81,0x04,0x00,0x21,0x04,0x6A,0x30,0x68,0x02,0x01,0x01,0x04,0x1C,0xBB,0x5A,0x95,0x9B,0xEF,0xAD,0x07,0xCD,0x6A,0x4A,0xB0,0x39,0x21,0x63,0x22,0x8F,0x29,0x2C,0x11,0x8A,0x51,0x45,0xCB,0xC7,0x64,0x97,0x66,0x4D,0xA0,0x07,0x06,0x05,0x2B,0x81,0x04,0x00,0x21,0xA1,0x3C,0x03,0x3A,0x00,0x04,0x92,0x9D,0x7C,0x17,0x68,0xD9,0x9D,0xEE,0x3A,0x47,0x54,0xBB,0x14,0x94,0x7D,0xAF,0x61,0x3D,0xEA,0x49,0xEE,0x35,0x5D,0xC6,0xC2,0x8D,0x17,0xC1,0xDD,0xCF,0x74,0xC3,0x27,0xFC,0x6C,0xA6,0x0E,0x81,0xE8,0xA2,0x02,0xB4,0x96,0x34,0x20,0xF1,0x53,0xDD,0x7B,0x18,0xB7,0xDB,0x81,0x79,0x43,0x3D,0x30,0x3D,0x02,0x1D,0x00,0x95,0x77,0x08,0x94,0x33,0x42,0x30,0x38,0x6E,0x11,0xDB,0x03,0x19,0x04,0xE9,0xA6,0xAC,0x49,0xDD,0x34,0xC1,0xB9,0x3E,0xFC,0x82,0x39,0x08,0x9C,0x02,0x1C,0x31,0x10,0x68,0x07,0xD0,0x37,0x20,0x4F,0xD5,0xE4,0xEE,0xA7,0x95,0x53,0x07,0xA1,0x34,0x5C,0x55,0x6A,0x40,0x54,0x2C,0x8D,0x26,0xE2,0x49,0x5D,0x33,0xC4,0x57,0xE1,0x75,0xD6,0xEC,0xDD,0x06,0xE2,0xAB,0x9A,0x3C,0xE4,0x96,0xB5,0x42,0x63,0xC5,0x71,0x7A,0x65,0x02,0xE7,0xF9,0x7B,0xA6,0x3D,0x68,0x23,0xF5,0x21,0x4F,0x9F,0x35,0xA3,0xF4,0xCC,0x75,0xA4,0xEF,0x90,0xA7,0x15,0x47,0x1B,0x8D,0xE2,0x02,0x7A,0x9C,0x43,0xC9,0xA7,0x9C,0xB2,0xA2,0x5A,0xBE,0x19,0x48,0x66,0x25,0x17,0xB7,0x74,0x4D,0x85,0xEC,0x23,0xD7,0x8B,0xAC,0x76,0xA7,0x73,0xCA,0x90,0xAC,0x18,0x79,0x14,0x51,0xFA,0x5C,0xF5,0x6A,0x18,0x08,0xD0,0x0C,0x61,0x9C,0xC7,0x92,0x2B,0x23,0x4A,0xB5,0x81,0xBA,0xFD,0x62,0x26,0xCC,0xBD,0x64,0xF9,0x0C,0x3C,0x33,0xC0
		0x0A,0x9B,0xD8,0x13,0x97,0x1F,0x93,0xE8,0x6B,0x7E,0xDF,0x05,0x70,0x54,0x02,0x02,0x02,0x01,0x41,0x01,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x96,0x00,0x48,0x30,0x81,0x93,0x02,0x01,0x00,0x30,0x13,0x06,0x07,0x2A,0x86,0x48,0xCE,0x3D,0x02,0x01,0x06,0x08,0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x07,0x04,0x79,0x30,0x77,0x02,0x01,0x01,0x04,0x20,0x37,0x48,0xFD,0xE5,0xBA,0x05,0x97,0x7B,0xA5,0x7A,0x14,0x0D,0xAA,0xEE,0xEA,0x73,0xA9,0xAB,0xF2,0xD3,0x90,0x99,0x46,0x18,0xA8,0xAC,0x8B,0xE3,0xFD,0xC4,0x58,0x4C,0xA0,0x0A,0x06,0x08,0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x07,0xA1,0x44,0x03,0x42,0x00,0x04,0x5C,0x12,0xEE,0x51,0xB8,0x38,0x27,0x12,0xFB,0xAD,0x30,0xA6,0xA3,0x40,0x3C,0x37,0x38,0xE7,0x62,0x80,0x48,0xDC,0x90,0x20,0xF3,0x8F,0x48,0x88,0x90,0xB0,0xEE,0x11,0xEA,0xAE,0x9B,0x97,0x02,0xE7,0xAA,0xA8,0xB4,0x3B,0xE5,0x94,0x10,0x5C,0x11,0xFC,0xF0,0x22,0xEF,0x83,0x6F,0xFA,0x80,0xEE,0xB6,0x92,0xF8,0x37,0x4D,0x38,0x85,0xA2,0x30,0x46,0x02,0x21,0x00,0x8B,0x73,0xAF,0x30,0xDC,0xE1,0x3D,0xB1,0x34,0xA1,0x7C,0x2C,0x6A,0xAE,0x32,0x46,0xF1,0x4D,0xF3,0xCE,0xB6,0xB3,0xC1,0x8E,0x7C,0x28,0x9F,0xF3,0xD9,0x14,0xB3,0xF6,0x02,0x21,0x00,0xF3,0x3E,0x99,0xBD,0xDB,0xC2,0xFD,0x60,0xC6,0x3D,0x33,0xBA,0x01,0xD5,0xC8,0x10,0xC4,0x8C,0xD6,0xD1,0xC8,0xBC,0x3D,0x46,0x7F,0x10,0xA0,0xF8,0x38,0x7B,0x6A,0x97,0x2A,0x5F,0x4C,0xB2,0x18,0xD9,0x16,0xA8,0xE4,0x24,0xD7,0x02,0xCB,0x2E,0xE8,0x66,0x0D,0x12,0xE3,0x07,0x8A,0xCB,0xAE,0xF7,0x5B,0x5C,0xD2,0xC2,0x29,0x23,0x52,0x4E,0x9C,0xA4,0x39,0xAF,0xF8,0x9B,0x7C,0xF4,0xE0,0x80,0xBE,0xBA,0x2B,0x9F,0xAB,0x94,0x3D,0x05,0x57,0x28,0x42,0xFD,0x6D,0x0E,0x2A,0x3D,0x42,0x92,0x9A,0xCF,0xF5,0x4E,0x5F,0x1A,0xBC,0x60,0x5F,0x29,0xAD,0x6C,0x80,0xC9,0x40,0x72,0x77,0xDF,0xE5,0xFC,0xF4,0x31,0x29,0x88,0xF4,0xAB,0xAB,0xB3,0xF3,0x88,0x57,0xC7,0x2F,0x76,0x89,0x74,0x8C,0x8F,0x20,0x4F,0xF2,0xBE,0x6B,0xF2,0x8D,0x1B,0x14,0xEC,0xC5,0x31,0x5C,0x52
	};
	const unsigned char pubkey[] = {
		//0x30,0x4E,0x30,0x10,0x06,0x07,0x2A,0x86,0x48,0xCE,0x3D,0x02,0x01,0x06,0x05,0x2B,0x81,0x04,0x00,0x21,0x03,0x3A,0x00,0x04,0xEA,0x0E,0x8D,0xDC,0x64,0x9B,0xE6,0xCD,0x91,0xF9,0x84,0x32,0x2C,0xC1,0x9D,0x2B,0xB8,0xE0,0x29,0x8A,0x9D,0xA7,0x6B,0xA3,0xC3,0x1D,0xFB,0x15,0x7B,0xB2,0xB7,0xAD,0x1D,0x96,0x69,0xA0,0xA0,0x32,0x05,0xF8,0xBF,0x22,0x19,0x04,0xB0,0x41,0xDA,0x87,0x51,0xF2,0x2F,0xA4,0x8E,0xBA,0xFF,0x21
		0x30,0x59,0x30,0x13,0x06,0x07,0x2A,0x86,0x48,0xCE,0x3D,0x02,0x01,0x06,0x08,0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x07,0x03,0x42,0x00,0x04,0xFD,0x1E,0x0A,0x0C,0xB2,0x02,0xB2,0xD0,0xCC,0xE2,0x57,0x53,0x3C,0x60,0xAF,0xD9,0xDD,0xCC,0xA5,0x6B,0xAC,0x54,0xB5,0x6B,0xB9,0x85,0x3E,0x06,0x16,0x7D,0x2F,0x56,0x19,0xBA,0xB1,0x49,0x4C,0xF8,0x2D,0x48,0xA1,0x83,0x39,0x1B,0x13,0x9C,0xDA,0x05,0x0E,0xDF,0x0A,0x26,0xE0,0xFB,0x11,0x4E,0xA3,0x83,0x1E,0x3B,0x17,0x12,0xF6,0x02
	};
	signedsecurefile::Key key;

	ERR_load_crypto_strings();

	//printf("setRSAPublickey : %d\n", key.setRSAPublicKey(pubkey, sizeof(pubkey)));
	printf("setECPublicKey : %d\n", key.setECPublicKey(pubkey, sizeof(pubkey)));
	signedsecurefile::InputStream inputstream(&key, "1234");
	printf("input : %d\n", inputstream.input(encData, 100));
	printf("input : %d\n", inputstream.input(encData + 100, sizeof(encData) - 100));
	printf("done : %d\n", inputstream.done());

	printf(" INPUT : [");
	unsigned char x;
	int rc;
	int size = 0;
	while ((rc = inputstream.read(&x, 1)) > 0) {
		printf("%c", x);
		size ++;
	}
	printf("] %d\n", size);
	return 0;
}
#elif 0
int main() {
	RSA *rsa = RSA_generate_key(1024, 0x10001, NULL, NULL);
	ERR_load_ERR_strings();

	signedsecurefile::Key keyA;
	keyA.setOpensslRSAKey(rsa);
	signedsecurefile::OutputStream outputStream(&keyA, "1234");
	outputStream.write((unsigned char*)"TEST123412341234AX", 18);
	outputStream.save();
	signedsecurefile::Buffer *buf = outputStream.toBuffer();

	signedsecurefile::Key keyB;
	keyB.setOpensslRSAKey(rsa);
	signedsecurefile::InputStream inputStream(&keyA, "1234");
	printf("inputStream.input : %d\n", inputStream.input(buf->buffer(), buf->readRemaining()));
	printf("inputStream.done : %d\n", inputStream.done());

	printf("PUB KEY : ");
	unsigned char pubKeyBuf[4096] = {0};
	unsigned char *ppubKeyBuf = pubKeyBuf;
	int pubKeySize = i2d_RSAPublicKey(rsa, &ppubKeyBuf);
	printf("%d\n", pubKeySize);
	for (int i = 0; i < pubKeySize; i ++)
	{
		printf("%02x ", pubKeyBuf[i]);
	}
	printf("\nOUTPUT : ");
	for (int i = 0, count = buf->readRemaining(); i < count; i++)
	{
		printf("%02x ", buf->buffer()[i]);
	}
	printf("\n");

	unsigned char readBuffer[1024] = {0};
	inputStream.read(readBuffer, sizeof(readBuffer));
	printf("%d : %s\n", 1, (const char*)readBuffer);
	
	return 0;
}
#else
int main() {
	EC_KEY *eckey = EC_KEY_new_by_curve_name(NID_secp224k1);
	EC_KEY_generate_key(eckey);
	ERR_load_ERR_strings();

	signedsecurefile::Key keyA;
	keyA.setOpensslECKey(eckey);
	signedsecurefile::OutputStream outputStream(&keyA, "1234");
	outputStream.write((unsigned char*)"TEST123412341234AX", 18);
	outputStream.save();
	signedsecurefile::Buffer *buf = outputStream.toBuffer();

	signedsecurefile::Key keyB;
	keyB.setOpensslECKey(eckey);
	signedsecurefile::InputStream inputStream(&keyA, "1234");
	printf("inputStream.input : %d\n", inputStream.input(buf->buffer(), buf->readRemaining()));
	printf("inputStream.done : %d\n", inputStream.done());

	exportECPubKey(eckey);
	/*
	printf("PUB KEY : ");
	unsigned char pubKeyBuf[4096] = { 0 };
	unsigned char *ppubKeyBuf = pubKeyBuf;
	int pubKeySize = i2o_ECPublicKey(eckey, &ppubKeyBuf);
	printf("%d\n", pubKeySize);
	for (int i = 0; i < pubKeySize; i++)
	{
		printf("(byte)0x%02x, ", pubKeyBuf[i]);
	}
	*/
	printf("\nOUTPUT : ");
	for (int i = 0, count = buf->readRemaining(); i < count; i++)
	{
		printf("(byte)0x%02x, ", buf->buffer()[i]);
	}
	printf("\n");

	unsigned char readBuffer[1024] = { 0 };
	inputStream.read(readBuffer, sizeof(readBuffer));
	printf("%d : %s\n", 1, (const char*)readBuffer);

	return 0;
}
#endif
